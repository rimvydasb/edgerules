<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/ast/functions/!uml-functions.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/ast/functions/!uml-functions.md" />
              <option name="originalContent" value="```mermaid&#10;classDiagram&#10;    class PredefinedFunctions {&#10;    }&#10;&#10;    class UnaryFunctionDefinition {&#10;        +eval(value: ValueEnum) Result&lt;ValueEnum, RuntimeError&gt;&#10;    }&#10;&#10;    class BinaryFunctionDefinition {&#10;        +eval(left: ValueEnum, right: ValueEnum) Result&lt;ValueEnum, RuntimeError&gt;&#10;    }&#10;&#10;    class MultiFunctionDefinition {&#10;        +eval(args: Vec&lt;ValueEnum&gt;) Result&lt;ValueEnum, RuntimeError&gt;&#10;        +eval(value: ValueEnum) Result&lt;ValueEnum, RuntimeError&gt;&#10;    }&#10;&#10;    class UserFunctionCall {&#10;        definition: Link&lt;FunctionContext&gt;&#10;        return_type: Link&lt;ValueType&gt;&#10;        +link(ctx) Link&lt;ValueType&gt;&#10;    }&#10;&#10;    class UnaryFunction {&#10;        -arg: ExpressionEnum&#10;        -return_type: Link&lt;ValueType&gt;&#10;        +link(ctx) Link&lt;ValueType&gt;&#10;    }&#10;&#10;    class BinaryFunction {&#10;        -left: ExpressionEnum&#10;        -right: ExpressionEnum&#10;        -return_type: Link&lt;ValueType&gt;&#10;        +link(ctx) Link&lt;ValueType&gt;&#10;    }&#10;&#10;    class MultiFunction {&#10;        -args: Vec&lt;ExpressionEnum&gt;&#10;        -return_type: Link&lt;ValueType&gt;&#10;        +link(ctx) Link&lt;ValueType&gt;&#10;    }&#10;&#10;    class BuiltInFunctionDefinition {&#10;        &lt;&lt;interface&gt;&gt;&#10;        +get_name() str&#10;        +get_default_return() Option&lt;ValueType&gt;&#10;        +get_input_validation() Option&lt;[ValueType]&gt;&#10;    }&#10;&#10;    class EvaluatableExpression {&#10;        &lt;&lt;interface&gt;&gt;&#10;        +eval(ctx) ...&#10;    }&#10;&#10;    %% Inheritance (as in the original)&#10;    UnaryFunctionDefinition &lt;|-- BuiltInFunctionDefinition&#10;    BinaryFunctionDefinition &lt;|-- BuiltInFunctionDefinition&#10;    MultiFunctionDefinition  &lt;|-- BuiltInFunctionDefinition&#10;&#10;    BuiltInFunctionDefinition &lt;|-- EvaluatableExpression&#10;    UserFunctionCall         &lt;|-- EvaluatableExpression&#10;&#10;    %% Associations / Aggregations / Compositions&#10;    PredefinedFunctions *-- &quot;n&quot; UnaryFunctionDefinition : definition&#10;    UnaryFunction o-- &quot;1&quot; UnaryFunctionDefinition : definition&#10;&#10;    PredefinedFunctions *-- &quot;n&quot; MultiFunctionDefinition : definition&#10;    MultiFunction o-- &quot;1&quot; MultiFunctionDefinition : definition&#10;&#10;    PredefinedFunctions *-- &quot;n&quot; BinaryFunctionDefinition : definition&#10;    BinaryFunction o-- &quot;1&quot; BinaryFunctionDefinition : definition&#10;&#10;    %% Notes&#10;    note for UserFunctionCall &quot;a = insurance(1000, 0.1, 10)&quot;&#10;    note for UnaryFunction &quot;a = sin(45)&quot;&#10;    note for BinaryFunction &quot;a = find([1,2,3], 2)&quot;&#10;    note for MultiFunction &quot;a = sum(1,2,5)&quot;&#10;```" />
              <option name="updatedContent" value="```mermaid&#10;classDiagram&#10;    class PredefinedFunctions {&#10;    }&#10;&#10;    class UnaryFunctionDefinition {&#10;        +eval(value: ValueEnum) Result&lt;ValueEnum, RuntimeError&gt;&#10;    }&#10;&#10;    class BinaryFunctionDefinition {&#10;        +eval(left: ValueEnum, right: ValueEnum) Result&lt;ValueEnum, RuntimeError&gt;&#10;    }&#10;&#10;    class MultiFunctionDefinition {&#10;        +eval(args: Vec&lt;ValueEnum&gt;) Result&lt;ValueEnum, RuntimeError&gt;&#10;        +eval(value: ValueEnum) Result&lt;ValueEnum, RuntimeError&gt;&#10;    }&#10;&#10;    class UserFunctionCall {&#10;        definition: Link&lt;FunctionContext&gt;&#10;        return_type: Link&lt;ValueType&gt;&#10;        +link(ctx) Link&lt;ValueType&gt;&#10;    }&#10;&#10;    class UnaryFunction {&#10;        -arg: ExpressionEnum&#10;        -return_type: Link&lt;ValueType&gt;&#10;        -definition: UnaryFunctionDefinition&#10;        +link(ctx) Link&lt;ValueType&gt;&#10;    }&#10;&#10;    class BinaryFunction {&#10;        -left: ExpressionEnum&#10;        -right: ExpressionEnum&#10;        -return_type: Link&lt;ValueType&gt;&#10;        -definition: BinaryFunctionDefinition&#10;        +link(ctx) Link&lt;ValueType&gt;&#10;    }&#10;&#10;    class MultiFunction {&#10;        -args: Vec&lt;ExpressionEnum&gt;&#10;        -return_type: Link&lt;ValueType&gt;&#10;        -definition: MultiFunctionDefinition&#10;        +link(ctx) Link&lt;ValueType&gt;&#10;    }&#10;&#10;    class BuiltInFunctionDefinition {&#10;        &lt;&lt;interface&gt;&gt;&#10;        +get_name() str&#10;        +get_default_return() Option&lt;ValueType&gt;&#10;        +get_input_validation() Option&lt;[ValueType]&gt;&#10;    }&#10;&#10;    class EvaluatableExpression {&#10;        &lt;&lt;interface&gt;&gt;&#10;        +eval(ctx) ...&#10;    }&#10;&#10;    %% Inheritance (as in the original)&#10;    UnaryFunctionDefinition &lt;|-- BuiltInFunctionDefinition&#10;    BinaryFunctionDefinition &lt;|-- BuiltInFunctionDefinition&#10;    MultiFunctionDefinition  &lt;|-- BuiltInFunctionDefinition&#10;&#10;    BuiltInFunctionDefinition &lt;|-- EvaluatableExpression&#10;    UserFunctionCall         &lt;|-- EvaluatableExpression&#10;&#10;    %% Associations / Aggregations / Compositions&#10;    PredefinedFunctions *-- &quot;n&quot; UnaryFunctionDefinition : definition&#10;    UnaryFunction o-- &quot;1&quot; UnaryFunctionDefinition : definition&#10;    UnaryFunction o-- &quot;1&quot; ValueType : return_type&#10;&#10;    PredefinedFunctions *-- &quot;n&quot; MultiFunctionDefinition : definition&#10;    MultiFunction o-- &quot;1&quot; MultiFunctionDefinition : definition&#10;    MultiFunction o-- &quot;1&quot; ValueType : return_type&#10;&#10;    PredefinedFunctions *-- &quot;n&quot; BinaryFunctionDefinition : definition&#10;    BinaryFunction o-- &quot;1&quot; BinaryFunctionDefinition : definition&#10;    BinaryFunction o-- &quot;1&quot; ValueType : return_type&#10;&#10;    %% Notes&#10;    note for UserFunctionCall &quot;a = insurance(1000, 0.1, 10)&quot;&#10;    note for UnaryFunction &quot;a = sin(45)&quot;&#10;    note for BinaryFunction &quot;a = find([1,2,3], 2)&quot;&#10;    note for MultiFunction &quot;a = sum(1,2,5)&quot;&#10;```&#10;&#10;---" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>